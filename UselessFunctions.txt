__host__ void CostComputation (Mat censusL, Mat censusR, int* cost, int maxDisparity){
	int imageL = censusL.rows;
	int imageW = censusL.cols;
	for(int y=0;y<imageL;y++){
		for(int xl=0;xl<imageW;xl++){
			int start = xl-maxDisparity;
			if (start < 0){
				start = 0;
			}
			for(int xr = start; xr<=xl;xr++){
				int dis = xl-xr; //Dont Know if abs
				unsigned int valueLeft = (unsigned int)censusL.at<uchar>(y,xl);
				unsigned int valueRight = (unsigned int)censusR.at<uchar>(y,xr);
				cost[imageW*(y+dis*(maxDisparity+1))+xr] = HammingDistance(valueLeft,valueRight);
				/*if(HammingDistance(valueLeft,valueRight) <= 0){
									cout << "here " << HammingDistance(valueLeft,valueRight) << " pixels "<< y<< " "<< xl << " "<<dis << "\t"<< valueLeft << "\t"<< valueRight<<endl;
								}*/
				//cout << valueLeft << " " << valueRight << " " <<  HammingDistance(valueLeft,valueRight)<< " disparity "<< dis << endl;
			}
		}
	}
}

//Calculate initial cost matrix between 9x7 windows, from the census transformed images.
__host__ Mat InitialDisparity(Mat censusL, Mat censusR, int boxWidth, int boxLength){
	cout << "Started Disparity" <<endl;
	Mat disparityMap(censusL.cols-boxWidth,censusL.rows-boxLength,CV_8U, Scalar(0,0,0));
	for(int y=boxLength/2;y<=censusL.rows-boxLength/2;y+boxLength){
		for(int xl=boxWidth/2;xl<=censusL.cols-boxWidth/2;xl+boxWidth){
			int disparity = 0;
			int cost      = numeric_limits<int>::max();

			for(int xr=boxWidth/2;xr<=censusL.cols-boxWidth/2;xr+boxWidth){
				float tempCost = 0;
				for(int yoffset=-boxLength/2;yoffset<=boxLength/2;yoffset++){
					for(int xoffset=-boxWidth/2;xoffset<=boxWidth/2;xoffset++){
						int valueLeft = censusL.at<uchar>(y+yoffset,xl+xoffset);
						int valueRight = censusR.at<uchar>(y+yoffset,xr+xoffset);
						tempCost = tempCost + HammingDistance((unsigned int) valueLeft,(unsigned int)valueRight);
					}
				}
				if(tempCost<cost){
					cost = tempCost;
					disparity = xl - xr;
				}
			}
			//cout << "pixel " << xl << " " << y << " disparity value " << disparity << endl;
			disparityMap.at<uchar>(y,xl) = disparity;
		}
	}
	cout << "Done disparity" << endl;
	return disparityMap;
}

__host__ void CostComputationArray (unsigned int* censusL, unsigned int* censusR, int* cost, int maxDisparity, int width, int length){
	cout << width << " " << length << endl;
	for(int y=0;y<length;y++){
		for(int x=0;x<width;x++){
			if(censusL[y*width + x]<=0){
				cout <<"zero pixel " << x << " " << y <<endl;
				waitKey(0);
			}
		}
	}

	int imageL = length;
	int imageW = width;
	for(int y=0;y<imageL;y++){
		for(int xl=0;xl<imageW;xl++){
			int start = xl-maxDisparity;
			if (start < 0){
				start = 0;
			}
			for(int xr = start; xr<=xl;xr++){
				int dis = xl-xr; //Dont Know if abs
				unsigned int valueLeft = censusL[y*width+xl];
				unsigned int valueRight = censusR[y*width+xr];
				cost[imageW*(y+dis*(maxDisparity+1))+xr] = HammingDistance(valueLeft,valueRight);
				/*if(HammingDistance(valueLeft,valueRight) <= 0){
					cout << "here " << HammingDistance(valueLeft,valueRight) << " pixels "<< y<< " "<< xl << " "<<dis << "\t"<< valueLeft << "\t"<< valueRight<<endl;
				}*/
				//cout << valueLeft << "\t " << valueRight << "\t " <<  HammingDistance(valueLeft,valueRight)<< " \t disparity "<< dis << endl;
			}
		}
	}

}


__host__ void CostComputation (unsigned int* censusL, unsigned int* censusR, int* cost, int maxDisparity, int width, int length){
	/*for(int y=0;y<length;y++){
		for(int xl=0;xl<width;xl++){
			int start = xl-(int)(maxDisparity);

			unsigned int valueLeft = censusL[y*width+xl];
			for(int xr = start+1; xr<=xl; xr++){
				int valueToAssigned;
				int dis = xl-xr;
				if(xr<0){
					unsigned int valueRight = censusR[y*width+xr];
					valueToAssigned = HammingDistanceNumbers(valueLeft,valueRight);
				}
				else{
					valueToAssigned = 99999;
				}
				cost[width*(y+dis*(maxDisparity))+xr] =valueToAssigned;
				if(HammingDistanceNumbers(valueLeft,valueRight) <= 0){
					cout << "here " << HammingDistanceNumbers(valueLeft,valueRight) << " pixels "<< y<< " "<< xl << " "<<dis << "\t"<< valueLeft << "\t"<< valueRight<<endl;
				}
				//cout << valueLeft << "\t " << valueRight << "\t " <<  HammingDistanceNumbers(valueLeft,valueRight)<< " \t disparity "<< dis << endl;
			}
		}
	}*/
}



//Increases textures on images.
__host__ void CensusTransformation (Mat image, int widthW, int lengthW, unsigned int* censusArray){
	unsigned int census = 0;
	int shiftCount = 0;

	int width = image.cols - widthW/2 - widthW/2;

	for (int y = lengthW / 2; y < image.rows - lengthW / 2; y++) {
		for (int x = widthW / 2; x < image.cols - widthW / 2; x++) {
			census = 0;
			shiftCount = 0;
			int xA = x - widthW / 2;
			int yA = y - lengthW / 2;

			//cout << "Centre Pixel " << x << "  " << y <<" " << (int) image.at<uchar>(y, x) << endl;
			for (int j = y - lengthW / 2; j <= y + lengthW / 2; j++) {
				for (int i = x - widthW / 2; i <= x + widthW / 2; i++) {
					//cout << i << " " <<j << "->" << (int) image.at<uchar>(j, i) << " ";
					if ((int) image.at<uchar>(y, x) < (int) image.at<uchar>(j, i) && shiftCount != widthW * lengthW / 2) {
						census <<= 1;
						census = census + 1;
					} else if (shiftCount != widthW * lengthW / 2) {
						census <<= 1;
					} /*else {
						cout << "skip ";
					}*/
					shiftCount++;
				}
			}
			/*cout << "\n" << "Resulting Value " << census << endl;
			waitKey(0);*/
			censusArray[yA * width + xA] = census;
		}
	}
}


__host__ int HammingDistanceNumbers (unsigned int a, unsigned int b){
	unsigned int val = a ^ b;
	int dist = 0;
	while(val != 0){
		val = val & (val-1);
		dist++;
	}
	return dist;
}


//ALL previous disparity
#include <stdio.h>
#include <iostream>
#include <string.h>
#include <limits>

#include "opencv2/core/core.hpp"
#include <opencv2/imgproc/imgproc.hpp>
#include "opencv2/highgui/highgui.hpp"

#define Camara 1
#define WIDTHIMAGE 640//1280
#define LENGTHIMAGE 533//720

using namespace std;
using namespace cv;

__host__ void disparityCalculations();
__host__ void DivideImages(Mat completeImage, Mat* left, Mat* rigth);
//Visualisation Only-------------
__host__ Mat CensusTransformation(Mat image, int widthW, int lengthW);
//-------------------------------
__host__ void CensusTransformationArray (Mat imageO, int widthW, int lengthW, unsigned int* censusArray);
__host__ void CostComputationArray (unsigned int* censusL, unsigned int* censusR, int* cost, int maxDisparity, int width, int length);
__host__ int HammingDistance(unsigned int a, unsigned int b);
__host__ void AggregateCost(int* cost, int* L, int width, int length,int maxDisparity, int directionx, int directiony);
__host__ int minBetweenNumbers(int a, int b, int c, int d);
__host__ int minArray (int* array, int x, int y, int maxD);
__host__ Mat DisparitySelection(int* L1, int* L2, int* L3, int* L4, int* L5, int* L6, int* L7, int* L8, int maxDisparity, int width, int length);



/*int main (int argc, char** argv){
	disparityCalculations();
	return 0;
}*/

__host__ void disparityCalculations(){
	Mat completeImage;
	Mat left,right,censusL,censusR, disparity;
	VideoCapture stream(Camara);

	//Box For Census Transform
	int cBW = 7;//5
	int cBL = 5;//7

	//Box For Disparity
	int dw  = 2;
	int dl  = 2;

	int maxDisparity = 128;

	unsigned int* censusLa = (unsigned int*)malloc((sizeof(unsigned int))*(WIDTHIMAGE-cBW)*(LENGTHIMAGE-cBL));
	unsigned int* censusRa = (unsigned int*)malloc((sizeof(unsigned int))*(WIDTHIMAGE-cBW)*(LENGTHIMAGE-cBL));

	int* cost = (int*)malloc((sizeof(int))*(WIDTHIMAGE-cBW)*(LENGTHIMAGE-cBL)*(maxDisparity+1));

	int* L1 = (int*)malloc((sizeof(int))*(WIDTHIMAGE-cBW)*(LENGTHIMAGE-cBL)*(maxDisparity+1));
	int* L2 = (int*)malloc((sizeof(int))*(WIDTHIMAGE-cBW)*(LENGTHIMAGE-cBL)*(maxDisparity+1));
	int* L3 = (int*)malloc((sizeof(int))*(WIDTHIMAGE-cBW)*(LENGTHIMAGE-cBL)*(maxDisparity+1));
	int* L4 = (int*)malloc((sizeof(int))*(WIDTHIMAGE-cBW)*(LENGTHIMAGE-cBL)*(maxDisparity+1));
	int* L5 = (int*)malloc((sizeof(int))*(WIDTHIMAGE-cBW)*(LENGTHIMAGE-cBL)*(maxDisparity+1));
	int* L6 = (int*)malloc((sizeof(int))*(WIDTHIMAGE-cBW)*(LENGTHIMAGE-cBL)*(maxDisparity+1));
	int* L7 = (int*)malloc((sizeof(int))*(WIDTHIMAGE-cBW)*(LENGTHIMAGE-cBL)*(maxDisparity+1));
	int* L8 = (int*)malloc((sizeof(int))*(WIDTHIMAGE-cBW)*(LENGTHIMAGE-cBL)*(maxDisparity+1));


	if (!stream.isOpened()) {
		cout << "No camera";
	}



	//Main Loop--------------------
/*	while(true){
		if(waitKey(10) >= 1){
			break;
		}*/
	/*for (int i =0; i<30;i++){
		stream.read(completeImage);
	}

		DivideImages(completeImage,&left,&right);
		namedWindow("left");
		namedWindow("right");
		imshow("left",left);
		imshow("right",right);
		waitKey(0);*/

		left = imread("Images/Left.ppm", CV_LOAD_IMAGE_COLOR);
		right= imread("Images/Right.ppm", CV_LOAD_IMAGE_COLOR);

		cout << left.rows << " " << left.cols << " " <<right.rows << " " << right.cols << endl;
		namedWindow("left");
		namedWindow("right");
		imshow("left",left);
		imshow("right",right);
		waitKey(0);


/*
		censusL = CensusTransformation(left,cBW,cBL);
		censusR = CensusTransformation(right,cBW,cBL);
		CostComputation(censusL,censusR,cost,maxDisparity);
*/


		CensusTransformationArray(left,cBW,cBL,censusLa);
		CensusTransformationArray(right,cBW,cBL,censusRa);
		CostComputationArray(censusLa,censusRa,cost,maxDisparity,WIDTHIMAGE-cBW,LENGTHIMAGE-cBL);


/*

		namedWindow("CensusL", CV_WINDOW_AUTOSIZE);
		namedWindow("CensusR", CV_WINDOW_AUTOSIZE);

		imshow("CensusL",censusL);
		imshow("CensusR",censusR);
		waitKey(0);
*/


		cout << "starting computation \n";
		//AggregateCost(cost,L1,WIDTHIMAGE,LENGTHIMAGE,maxDisparity,-1,-1);
		AggregateCost(cost,L2,WIDTHIMAGE-cBW,LENGTHIMAGE-cBL,maxDisparity,0,-1);
		//AggregateCost(cost,L3,WIDTHIMAGE,LENGTHIMAGE,maxDisparity,1,-1);
		AggregateCost(cost,L4,WIDTHIMAGE-cBW,LENGTHIMAGE-cBL,maxDisparity,-1,0);
		AggregateCost(cost,L5,WIDTHIMAGE-cBW,LENGTHIMAGE-cBL,maxDisparity,1,0);
		//AggregateCost(cost,L6,WIDTHIMAGE,LENGTHIMAGE,maxDisparity,-1,1);
		AggregateCost(cost,L7,WIDTHIMAGE-cBW,LENGTHIMAGE-cBL,maxDisparity,0,1);
		//AggregateCost(cost,L8,WIDTHIMAGE,LENGTHIMAGE,maxDisparity,1,1);
		cout << "Complete Aggregate Cost " << endl;

		disparity= DisparitySelection(L1,L2,L3,L4,L5,L6,L7,L8, maxDisparity,WIDTHIMAGE-cBW,LENGTHIMAGE-cBL);

		//Display Images
		imwrite("disparity.jpg",disparity);

		namedWindow("disparity");
		imshow("disparity",disparity);
		waitKey(0);

	/*}*/
	//Main Loop--------------------
	free(cost);
	free(L1);
	free(L2);
	free(L3);
	free(L4);
	free(L5);
	free(L6);
	free(L7);
	free(L8);
	free(censusLa);
	free(censusRa);
}

//Pixel-wise matching cost computation

__host__ void CostComputationArray (unsigned int* censusL, unsigned int* censusR, int* cost, int maxDisparity, int width, int length){
	cout << width << " " << length << endl;
	for(int y=0;y<length;y++){
		for(int x=0;x<width;x++){
			if(censusL[y*width + x]<=0){
				cout <<"zero pixel " << x << " " << y <<endl;
				waitKey(0);
			}
		}
	}

	int imageL = length;
	int imageW = width;
	for(int y=0;y<imageL;y++){
		for(int xl=0;xl<imageW;xl++){
			int start = xl-(int)(maxDisparity/2);
			int end   = xl +(int)(maxDisparity/2);
			if (start < 0){
				start = 0;
			}
			for(int xr = start; xr<=end;xr++){
				int dis = xl-xr; //Dont Know if abs
				if (dis < 0){
					dis = xr - xr + (int)(maxDisparity/2);
				}


				unsigned int valueLeft = censusL[y*width+xl];
				unsigned int valueRight = censusR[y*width+xr];
				cost[imageW*(y+dis*(maxDisparity+1))+xr] = HammingDistance(valueLeft,valueRight);
				/*if(HammingDistance(valueLeft,valueRight) <= 0){
					cout << "here " << HammingDistance(valueLeft,valueRight) << " pixels "<< y<< " "<< xl << " "<<dis << "\t"<< valueLeft << "\t"<< valueRight<<endl;
				}*/
				//cout << valueLeft << "\t " << valueRight << "\t " <<  HammingDistance(valueLeft,valueRight)<< " \t disparity "<< dis << endl;
			}
		}
	}

}

__host__ Mat DisparitySelection(int* L1, int* L2, int* L3, int* L4, int* L5, int* L6, int* L7, int* L8, int maxDisparity, int width, int length){
	Mat disparity(LENGTHIMAGE,WIDTHIMAGE,CV_8U);

	for(int y=0; y<length; y++){
		for(int x=0; x<width; x++){
			int costA = 509;
			int disPix = 0;
			for (int d = 0; d<=maxDisparity; d++){
				int sumAgg = /*L1[width*(y+d*maxDisparity)+x] +*/ L2[width*(y+d*(maxDisparity+1))+x]+
						/*L3[width*(y+d*maxDisparity)+x] +*/ L4[width*(y+d*(maxDisparity+1))+x] + L5[width*(y+d*(maxDisparity+1))+x]+
						/*L6[width*(y+d*maxDisparity)+x] +*/ L7[width*(y+d*(maxDisparity+1))+x] /*+ L8[width*(y+d*maxDisparity)+x]*/;
				if (sumAgg < costA){
					costA = sumAgg;
					disPix = d;
				}
 			}
			if(disPix > maxDisparity/2){
				disPix = disPix - maxDisparity/2;
			}
			cout << "disparity pixel " <<x << " " << y << " is " << disPix << " with value "<< costA<< endl;
			disparity.at<uchar>(y,x) = disPix;
		}
	}

	return disparity;
}

//Aggregate Cost Function
__host__ void AggregateCost(int* cost, int* L, int width, int length, int maxDisparity, int directionx, int directiony){
	//penalties
	int p1 = 1;
	int p2 = 2;

	int startX,startY, increaseX, increaseY;

/*
	int increaseX = directionx * -1;
	int increaseY = directiony * -1;
*/

	if(directionx <= 0){
		startX = 0;
		increaseX = 1;
	}
	else{
		startX = width-1;
		increaseX = -1;
	}
	if(directiony <= 0){
		startY = 0;
		increaseY = 1;
	}
	else{
		startY = length-1;
		increaseY = -1;
	}

	int* minimuns = (int*)malloc((sizeof(int))*(width)*(length));

	int x;
	int y = startY;


	for(int yC=0; yC<length; yC++){
		int influenceY = y + directiony;
		x = startX;
		for(int xC=0; xC<width; xC++){
			int influenceX = x + directionx;

			int minimunValue = 77777;
			if(influenceX > width-1 || influenceX < 0 || influenceY > length-1 || influenceY < 0){
				for (int d = 0; d<=maxDisparity; d++){
					int costPixel = cost[width*(y+d*(maxDisparity+1))+x];
					L[width*(y+d*(maxDisparity+1))+x] = costPixel;
					if(costPixel < minimunValue){
						minimunValue = costPixel;
						//cout << "minimum ->  " << costPixel;
					}
				}
			}
			else{
				/*cout << x << " " << y <<endl;
				waitKey(0);*/
				for (int d = 0;  d<=maxDisparity; d++){
					int costPixel = cost[width*(y+d*(maxDisparity+1))+x];
					int currentD = L[width*(influenceY+d*(maxDisparity+1))+influenceX];
					int previousD= (d-1>=0)? L[width*(influenceY+(d-1)*(maxDisparity+1))+influenceX]: 8888;
					int nextD    = (d+1<=maxDisparity)? L[width*(influenceY+(d+1)*(maxDisparity+1))+influenceX] : 8888;
					//int minValue  = minArray(L,influenceX,influenceY,maxDisparity);
					int minValue =minimuns[influenceY*width+influenceX];
					int valueToAssign =  costPixel + minBetweenNumbers(currentD,nextD+p1,previousD+p1,minValue+p2) - minValue;
					L[width*(y+d*(maxDisparity+1))+x] = valueToAssign;
					if(valueToAssign < minimunValue){
						minimunValue = valueToAssign;
					}

					/*if(valueToAssign <= 0){
						cout << x<<" "<<y<<"\t influence "<< influenceX << " " << influenceY << endl;
						cout << "Pixels: "<<x<<"-"<<y<<"\t"<<"Formula: " <<costPixel << "\t min["<< currentD << "\t"<< previousD << "\t"
							<<nextD<<"\t"<<minValue<< "]" <<"\t Result Value: " <<valueToAssign<< "\t"<< d <<endl;
						waitKey(0);
					}*/
				}
				minimuns[y*width+x] = minimunValue;
			}
			x = x + increaseX;
		}
		y = y + increaseY;
	}


	cout << "done Aggregate Cost direction "<<directionx << " " << directiony << endl;
	free(minimuns);
}

__host__ int minBetweenNumbers(int a, int b, int c, int d){
	int min = a;

	if (min > b){
		min = b;
	}
	if (min > c){
		min = c;
	}
	if (min > d){
		min = d;
	}
	return min;
}

__host__ int minArray (int* array, int x, int y, int maxD){
	int min=509;
	for(int i =0; i<=maxD;i++){
		int value = array[WIDTHIMAGE*(y+i*maxD)+x];
		if (value < min){
			min = value;
		}
	}
	return min;
}



__host__ void DivideImages(Mat completeImage, Mat* left, Mat* right){
	*left = completeImage(Rect(0,0,WIDTHIMAGE,LENGTHIMAGE));
	*right = completeImage(Rect(1280,0,WIDTHIMAGE,LENGTHIMAGE));
}

__host__ void CensusTransformationArray (Mat imageO, int widthW, int lengthW, unsigned int* censusArray){
	Mat image;
	cvtColor( imageO, image, CV_BGR2GRAY );

	unsigned int census=0;
	int shiftCount   = 0;
	int width = image.cols-widthW;

	for(int y=lengthW/2;y<image.rows-lengthW/2;y++)
	{
	  for (int x=widthW/2;x<image.cols-widthW/2;x++)
	  {
		  census = 0;
		  shiftCount = 0;

		  int xA = x - widthW/2;
		  int yA = y - lengthW/2;

		  for(int j = y-lengthW/2;j<=y+lengthW/2;j++){
			  for(int i = x-widthW/2;i<=x+widthW/2;i++){
				  //cout << "Pixel Values: " << (int) image.at<uchar>(y,x) << " " << (int) image.at<uchar>(j,i) << endl;

				  if((int) image.at<uchar>(y,x) <= (int) image.at<uchar>(j,i) && shiftCount != widthW*lengthW/2){
					  census <<= 1;
					  census = census +1;
				  }
				  else if (shiftCount != widthW*lengthW/2) {
					  census <<= 1;
				  }
				  shiftCount ++;
			  }
		  }
		  if(census == 0){
			  cout << "zero \n";
			  waitKey(0);
		  }
		  //cout << "x "<< x << " y " << y <<endl;
		  censusArray[yA*width+xA] = census;
		  //imgTemp.at<uchar>(y,x) = census;//white
	  }
	}


	for(int y=lengthW/2;y<image.rows-lengthW/2;y++)
		{
		  for (int x=widthW/2;x<image.cols-widthW/2;x++)
		  {
			  int xA = x - widthW/2;
			  int yA = y - lengthW/2;
			  //cout << "pixel " << xA << " " << yA << "\t" << censusArray[yA*width+xA] << endl;
			  if (censusArray[yA*width+xA]<=0){
				  cout << "zero Array " << x << " " << y << endl;
				  waitKey(0);
			  }
		  }
		}
}


//Visualization Purposes Only.......................................
__host__ Mat CensusTransformation(Mat imageO, int widthW, int lengthW){
	Mat image;
	cvtColor( imageO, image, CV_BGR2GRAY );
	Mat imgTemp = image.clone();
	unsigned int census=0;
	int shiftCount   = 0;
	for(int y=lengthW/2;y<=image.rows-lengthW/2;y++)
	{
	  for (int x=widthW/2;x<=image.cols-widthW/2;x++)
	  {
		  census = 0;
		  shiftCount = 0;
		  for(int j = y-lengthW/2;j<=y+lengthW/2;j++){
			  for(int i = x-widthW/2;i<=x+widthW/2;i++){

				  if(image.at<uchar>(y,x) < image.at<uchar>(j,i) && shiftCount != widthW*lengthW/2){
					  census <<= 1;
					  census = census +1;
				  }
				  else if (shiftCount != widthW*lengthW/2) {
					  census <<= 1;
					  census = census +0;
				  }
				  shiftCount ++;
			  }
		  }
		  //cout << "x "<< x << " y " << y <<endl;
		  imgTemp.at<uchar>(y,x) = census;//white
	  }
	}
	return imgTemp(Rect(widthW/2,lengthW/2,WIDTHIMAGE-widthW/2,LENGTHIMAGE-lengthW/2));
}

__host__ int HammingDistance(unsigned int a, unsigned int b){
	unsigned int val = a ^ b;
	int dist = 0;
	while(val != 0){
		val = val & (val-1);
		dist++;
	}
	return dist;
}



//Useless Kernel Functions
__device__ void PathCostKernelCols(int length, int directionX, int directionY, int* L, int* cost);
__device__ void PathCostKernelRows(int width, int directionX, int directionY, int* L, int* cost);

__global__ void callColsPathCost(int length, int directionX, int directionY, int* L, int* cost){
	PathCostKernelCols(length,directionX,directionY,L,cost);
}
__global__ void callRowsPathCost(int width, int directionX, int directionY, int* L, int* cost){
	PathCostKernelRows(width,directionX,directionY,L,cost);
}
//Kernel 2 Functions
__device__ void PathCostKernelCols(int length, int directionX, int directionY, int* L, int* cost){
	//To use this, blockNum Has to be width, and threadNum has to be disparity value
	__shared__ int previousResults[100];
	__shared__ int previousTemp[100];
	__shared__ int minimum;
	const int x = blockIdx.x;
	const int d = threadIdx.x;
	const int width = blockDim.x;
	int startY = (directionY == -1)? length : 0;
	int endY   = (directionY == -1)? 0 : length;

	int influenceX = -1;
	int influenceY = -1;
	int term1 = 0;//Cost of the pixel, given disparity
	int term2 = 0;//minimum path cost of previousPixel, with penalties.
	int term3 = 0;//minimum path cost of previousPixel, without penalties.
	int minToUse = 0;

	#pragma unroll 374
	for(int y = startY; y < endY; y++){
		minimum = 8888;
		term1 = cost[width*(y+d*(length))+x];
		if(influenceX >= 0 && influenceY >= 0){
			int currentD = previousResults[d];
			int previousD = (d - 1 >= 0) ? previousResults[d - 1] : 8888;
			int nextD = (d + 1 < maxDisparity) ? previousResults[d + 1] : 8888;
			term2 = minNumber(currentD,nextD+p1,previousD+p1,minToUse+p2);
			term3 = minToUse;
		}
		int valueToAssign = term1 + term2 - term3;
		L[width*(y+d*(length))+x] = L[width*(y+d*(length))+x] +  valueToAssign;

		if(valueToAssign < minimum){
			minimum = valueToAssign;
		}

		influenceY = y;
		minToUse = minimum;
		__syncthreads();
		swappArrays(previousResults,previousTemp);
	}
}

__device__ void PathCostKernelRows(int width, int directionX, int directionY, int* L, int* cost){
	//To use this, blockNum Has to be width, and threadNum has to be disparity value
	__shared__ int previousResults[100];
	__shared__ int previousTemp[100];
	__shared__ int minimum;
	const int y = blockIdx.x;
	const int d = threadIdx.x;
	const int length = blockDim.x;
	int startX = (directionX == -1)? width : 0;
	int endX   = (directionX == -1)? 0 : width;

	int influenceX = -1;
	int influenceY = -1;
	int term1 = 0;//Cost of the pixel, given disparity
	int term2 = 0;//minimum path cost of previousPixel, with penalties.
	int term3 = 0;//minimum path cost of previousPixel, without penalties.
	int minToUse = 0;

	#pragma unroll 1237
	for(int x = startX; y < endX; x++){
		minimum = 8888;
		term1 = cost[width*(y+d*(length))+x];
		if(influenceX >= 0 && influenceY >= 0){
			int currentD = previousResults[d];
			int previousD = (d - 1 >= 0) ? previousResults[d - 1] : 8888;
			int nextD = (d + 1 < maxDisparity) ? previousResults[d + 1] : 8888;
			term2 = minNumber(currentD,nextD+p1,previousD+p1,minToUse+p2);
			term3 = minToUse;
		}
		int valueToAssign = term1 + term2 - term3;
		L[width*(y+d*(length))+x] = L[width*(y+d*(length))+x] +  valueToAssign;

		if(valueToAssign < minimum){
			minimum = valueToAssign;
		}

		influenceX = x;
		minToUse = minimum;
		__syncthreads();
		swappArrays(previousResults,previousTemp);
	}
}


__global__ void CensusAndCostKernel(int boxCostX, int boxCostY, int widthImage, int lenImage, uchar* leftI, uchar* rightI, int* cost){
	//printf("Census \n");
	CensusAndCostCalculationKernel(boxCostX,boxCostY,widthImage,lenImage,leftI,rightI,cost);
	__syncthreads();
}

__device__ void CensusAndCostCalculationKernel(int widthBox, int lengthBox, int widthImage, int lenImage, uchar* leftI, uchar* rightI, int* cost){
	int yLR = threadIdx.y + (blockIdx.y * blockDim.y);
	int xL = (int)((threadIdx.x + (blockIdx.x * blockDim.x)) / 100);
	int d = (threadIdx.x + (blockIdx.x * blockDim.x)) % 100;
	int xR = xL - d;

	int wI = widthImage + widthBox;
	int x = xL + widthBox/2;
	int y = yLR+ lengthBox/2;
	unsigned int censusLCal = 0;
	unsigned int censusRCal = 0;
	unsigned int shiftCount=0;

	int valueLeft = (int)leftI[y*wI+x];
	int valueRight= (int)rightI[y*wI+x];

	int valueToAssign = 8888;
	if(xR >= 0){
		//Census
		for (int j = y - lengthBox / 2; j <= y + lengthBox / 2; j++) {
			for (int i = x - widthBox / 2; i <= x + widthBox / 2; i++) {
				int valueToCheckLeft = (int) leftI[j * wI + i];
				int valueTocheckRight = (int) rightI[j * wI + i];
				if (shiftCount != widthBox * lengthBox / 2) {
					//Left Census
					if (valueLeft < valueToCheckLeft) {
						censusLCal <<= 1;
						censusLCal = censusLCal + 1;
					} else {
						censusLCal <<= 1;
					}
					//Right Census
					if (valueRight < valueTocheckRight) {
						censusRCal <<= 1;
						censusRCal = censusRCal + 1;
					} else {
						censusRCal <<= 1;
					}
				}
			}
		}
		//Cost Computation
		valueToAssign = HammingDistanceKernel(censusLCal,censusRCal);
	}
	printf("valueToAssign:%d %d %d \n",xL,yLR,valueToAssign);
	cost[widthImage*(yLR+d*(lenImage))+xL] = valueToAssign;
}

__global__ void CensusAndCostKernel(int boxCostX, int boxCostY, int widthImage, int lenImage, uchar* leftI, uchar* rightI, int* cost);
__device__ void CensusAndCostCalculationKernel(int widthBox, int lengthBox, int widthImage, int lenImage, uchar* leftI, uchar* rightI, int* cost);





/*void Radar::test(){
	int fd;File Descriptor

	printf("\n +----------------------------------+");
	printf("\n |        Serial Port Read          |");
	printf("\n +----------------------------------+");

	------------------------------- Opening the Serial Port -------------------------------

	 Change /dev/ttyUSB0 to the one corresponding to your system

	fd = open(DATA_PORT, O_RDWR | O_NOCTTY);  ttyUSB0 is the FT232 based USB2SERIAL Converter
	 O_RDWR   - Read/Write access to serial port
	 O_NOCTTY - No terminal will control the process
	 Open in blocking mode,read will wait

	if (fd == -1)  Error Checking
		printf("\n  Error! in Opening ttyUSB0  ");
	else
		printf("\n Opened Successfully ");

	---------- Setting the Attributes of the serial port using termios structure ---------

	struct termios SerialPortSettings;  Create the structure

	tcgetattr(fd, &SerialPortSettings);  Get the current attributes of the Serial port

	 Setting the Baud rate
	cfsetispeed(&SerialPortSettings, B921600);  Set Read  Speed as 921600
	cfsetospeed(&SerialPortSettings, B921600);  Set Write Speed as 9600

	 8N1 Mode
	SerialPortSettings.c_cflag &= ~PARENB;  Disables the Parity Enable bit(PARENB),So No Parity
	SerialPortSettings.c_cflag &= ~CSTOPB;  CSTOPB = 2 Stop bits,here it is cleared so 1 Stop bit
	SerialPortSettings.c_cflag &= ~CSIZE;  Clears the mask for setting the data size
	SerialPortSettings.c_cflag |= CS8;  Set the data bits = 8

	SerialPortSettings.c_cflag &= ~CRTSCTS;  No Hardware flow Control
	SerialPortSettings.c_cflag |= CREAD | CLOCAL;  Enable receiver,Ignore Modem Control lines

	SerialPortSettings.c_iflag &= ~(IXON | IXOFF | IXANY);  Disable XON/XOFF flow control both i/p and o/p
	SerialPortSettings.c_iflag &= ~(ICANON | ECHO | ECHOE | ISIG);  Non Cannonical mode

	SerialPortSettings.c_oflag &= ~OPOST;No Output Processing

	 Setting Time outs
	SerialPortSettings.c_cc[VMIN] = 10;  Read at least 10 characters
	SerialPortSettings.c_cc[VTIME] = 0;  Wait indefinetly

	if ((tcsetattr(fd, TCSANOW, &SerialPortSettings)) != 0){  Set the attributes to the termios structure
		printf("\n  ERROR ! in Setting attributes");
	}
	else{
		printf("\n  BaudRate = 921600 \n  StopBits = 1 \n  Parity   = none");
	}
	------------------------------- Read data from serial port -----------------------------



	tcflush(fd, TCIFLUSH);  Discards old data in the rx buffer

	//Reading Header-------------------------------------------------------------
	char read_buffer[1024];  Buffer to store the data received
	int bytes_read = 0;  Number of bytes read by the read() system call

	bytes_read = read(fd, &read_buffer, sizeof(read_buffer));  Read the data
	printf("\n\n +----------------------------------+");
	printf("\n\nHeader: Total bytes: %d", bytes_read);  Print the number of bytes read
	printf("\n\n");

	//reading magicWord
	cout << "Magic Word: ";
	for (int i = 0; i < 8; i++) printing only the received characters
		printf("%d ", read_buffer[i]);
	cout << endl;

	unsigned int version = 0;
	for(int i = 11; i >= 8 ;i--){
		version <<= 8;
		version = version + (unsigned int)read_buffer[i];
		cout << (int)read_buffer[i] << " ";
	}
	cout << "Version: " << version << endl;

	unsigned int packetLength =0;
	for(int i = 15; i >= 12 ;i--){
		packetLength <<= 8;
		packetLength = packetLength + (int)read_buffer[i];
	}
	cout << "PacketLength: " << packetLength << endl;

	unsigned int platform = 0;
	for(int i = 19; i >= 16 ;i--){
		platform <<= 8;
		platform = platform + (int)read_buffer[i];
	}
	cout << "Platform: " << platform << endl;

	unsigned int frameNumber = 0;
	for(int i = 23; i >= 20 ;i--){
		frameNumber <<= 8;
		frameNumber = frameNumber + (int)read_buffer[i];
	}
	cout << "Frame Number: " << frameNumber << endl;

	unsigned int time = 0;
	for(int i = 27; i >= 24 ;i--){
		time <<= 8;
		time = time + (int)read_buffer[i];
	}
	cout << "Time: " << time << endl;

	unsigned int detectedObjects = 0;
	for (int i = 31; i >= 28; i--) {
		detectedObjects <<= 8;
		detectedObjects = detectedObjects + (int) read_buffer[i];
		//cout << (int) read_buffer[i] << " ";
	}
	cout << "Number of Detected Objects: " << detectedObjects << endl;

	unsigned int dataStructNum = 0;
	for (int i = 35; i >= 32; i--) {
		dataStructNum <<= 8;
		dataStructNum = dataStructNum + (int) read_buffer[i];
		//cout << (int) read_buffer[i] << " ";
	}

	cout << "Number of Data Structures: " << dataStructNum << endl;
	printf("\n +----------------------------------+ \n\n");
	//Reading  Detected Objects
	int sizeDetectedObjects = 12 + detectedObjects * 12;
	int byteToReadB = 36;

	unsigned int structureTag = 0;
	for (int i = byteToReadB+3; i >= byteToReadB; i--) {
		structureTag <<= 8;
		structureTag = structureTag + (int) read_buffer[i];
		cout << (int) read_buffer[i] << " ";
	}
	cout << "Structure Tag: " << structureTag << endl;
	byteToReadB = byteToReadB + 4;
	unsigned int lengthStruct = 0;
	for (int i = byteToReadB+3; i >= byteToReadB; i--) {
		lengthStruct <<= 8;
		lengthStruct = lengthStruct + (int) read_buffer[i];
		//cout << (int) read_buffer[i] << " ";
	}
	cout << "Length Structure: " << lengthStruct << endl;
	byteToReadB = byteToReadB + 4;

	unsigned int Descriptor1 = 0;
	for (int i = byteToReadB+1; i >= byteToReadB; i--) {
		Descriptor1 <<= 8;
		Descriptor1 =Descriptor1 + (int) read_buffer[i];
		//cout << (int) read_buffer[i] << " ";
	}
	byteToReadB = byteToReadB+2;
	cout << "Descriptor Num of detected Objects: " << Descriptor1 << endl;
	unsigned int Descriptor2 = 0;
	for (int i = byteToReadB+1; i >= byteToReadB; i--) {
		Descriptor2 <<= 8;
		Descriptor2 = Descriptor2 + (int) read_buffer[i];
		cout << "Byte " << (unsigned int)read_buffer[i] << endl;
		//cout << (int) read_buffer[i] << " ";
	}
	//Descriptor2 = (unsigned int)read_bufferDO[11];
	cout << "Descriptor 2:  " << Descriptor2 << endl;
	cout << "Descriptor XYZ Q format: " << pow(2,Descriptor2) << endl;
	float xyzQ = (float)pow((double)2,(double)Descriptor2);
	byteToReadB = byteToReadB + 2;
	cout << "Starting location Read byte: " << byteToReadB << endl;
	cout << "\nObject Information: \n";
	//This area depends on the number of Objects detected
	//Reading detected objects Range, doppler, peak, x,y,z each 2 bytes

	//Data to be send, creating fifo
	int fdf;
	char* myfifo = "/tmp/FIFO";

	 create the FIFO (named pipe)
	mkfifo(myfifo, 0666);

	 write message to the FIFO
	fdf = open(myfifo, O_WRONLY);
	//data to be send ---------------
	stringstream stream;
	stream << detectedObjects;

	for(int obj = 0; obj < detectedObjects; obj++){
		cout << "\nObject Number " << obj << " :\n";
		unsigned int range = 0;
		unsigned int doppler = 0;
		unsigned int peak = 0;
		int x = 0;
		int y = 0;
		int z = 0;

		//reading range
		for (int i = byteToReadB+1; i >= byteToReadB; i--) {
			range <<= 8;
			range = range + (unsigned int) read_buffer[i];
			//cout << (int) read_buffer[i] << " ";
		}
		cout << "Range: " << range << endl;

		for (int i = byteToReadB + 3; i >= byteToReadB +2; i--) {
			doppler <<= 8;
			doppler = doppler + (int) read_buffer[i];
			//cout << (int) read_buffer[i] << " ";
		}
		cout << "Doopler: " << doppler << endl;

		for (int i = byteToReadB + 5; i >= byteToReadB + 4; i--) {
			peak <<= 8;
			peak = peak + (int) read_buffer[i];
			//cout << (int) read_buffer[i] << " ";
		}
		cout << "Peak: " << peak << endl;

		//Points
		for (int i = byteToReadB + 7; i >= byteToReadB + 6; i--) {
			x <<= 8;
			x = x + (int) read_buffer[i];
			//cout << (int) read_buffer[i] << " ";
		}
		for (int i = byteToReadB + 9; i >= byteToReadB + 8; i--) {
			y <<= 8;
			y = y + (int) read_buffer[i];
			//cout << (int) read_buffer[i] << " ";
		}
		for (int i = byteToReadB + 11; i >= byteToReadB + 10; i--) {
			z <<= 8;
			z = z + (int) read_buffer[i];
			//cout << (int) read_buffer[i] << " ";
		}

		float xCoo = (float)x/xyzQ;
		float yCoo = (float)y/xyzQ;
		cout <<"Coordinates: " << xCoo << " " << yCoo << " " << (float)(z/Descriptor2) << endl;
		byteToReadB = byteToReadB + obj*12;
		stream << "\n";
		stream << fixed << setprecision(4) << xCoo;
		stream << " ";
		stream << fixed << setprecision(4) << yCoo;
	}

	string SendInfo = stream.str();
	write(fdf, SendInfo.c_str(), SendInfo.length());
	close(fdf);
	 remove the FIFO
	unlink(myfifo);
	cout << "done Passing info \n";
	printf("\n +----------------------------------+\n\n\n");

	//Reading Header------------------------------------------------

	close(fd);  Close the serial port

}*/

